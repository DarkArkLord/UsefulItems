<!DOCTYPE html>
<html>

<head>
    <title>Рисование графика</title>
</head>

<body>
    <div id="content-container">content</div>
</body>

<!-- TEST VALUES -->
<script>
    const valuesGenerators = {
        values1: () => {
            let res = [];
            for (let i = 0; i < 12; i++) {
                res.push({ x: i - 2, y: (i % 2 == 0 ? 1 : -1) * i });
            }
            res.push({ x: 9.5, y: 0 });
            return res;
        },
        values2: () => {
            let res = [];
            for (let i = 0; i < 12; i++) {
                res.push({ x: i - 2, y: (i % 2 == 0 ? -1 : 1) * i });
            }
            res.push({ x: 9.5, y: 0 });
            return res;
        },
        values3: () => {
            let res = [];
            for (let i = 0; i < 10; i++) {
                res.push({ x: i, y: 0.5 });
                res.push({ x: i + 0.5, y: -0.5 });
            }
            return res;
        },
        values4: () => {
            let res = [];
            for (let i = 0; i < 10; i++) {
                res.push({ x: i, y: -0.5 });
                res.push({ x: i + 0.5, y: 0.5 });
            }
            return res;
        },
    };

    const imageConfig = {
        image: {
            size: {
                full: { height: 700, width: 900, },
                client: { height: 600, width: 800, },
            },
            textSize: { width: 9.6, height: 18 },
            scales: {
                dynamicScales: false,
                hideValuesOutOfScales: true,
                xPoints: undefined,
                yPoints: undefined,
                xScaleValues: [2, 3, 4, 5, 6, 7, 8,],
                yScaleValues: [-7, -6, -5, -4, -3, -2, -1, 0, 1, 2, 3, 4, 5, 6, 7,],
                xText: 'X',
                yText: 'P',
            },
            colors: {
                imageBorder: 'black',
                scales: 'rgb(27, 27, 27)',
                scaleGrid: 'gray',
                text: 'black',
            },
        },
        lines: [
            {
                values: valuesGenerators.values1(),
                color: 'rgb(255, 0, 0)'
            },
            {
                values: valuesGenerators.values2(),
                color: 'rgb(0, 255, 0)'
            },
            {
                values: valuesGenerators.values3(),
                color: 'rgb(0, 0, 255)'
            },
            {
                values: valuesGenerators.values4(),
                color: 'rgb(0, 0, 255)'
            },
        ],
    }
</script>

<!-- SVG ELEMENT RENDER -->
<script>
    const SVGTags = {
        SVG: 'svg',
        Group: 'g',
        Line: 'line',
        Polyline: 'polyline',
        Text: 'text'
    }

    function renderSVG(tag, attributes, ...childs) {
        if (tag instanceof Function) {
            return tag(attributes, ...childs);
        }

        const element = document.createElementNS('http://www.w3.org/2000/svg', tag);

        if (attributes) {
            for (const name in attributes) {
                const value = attributes[name];
                element.setAttributeNS(null, name, value);
            }
        }

        for (const child of childs) {
            (function addChild(parent, child) {
                if (Array.isArray(child)) {
                    for (const innerChild of child) {
                        addChild(parent, innerChild);
                    }
                } else {
                    parent.appendChild(
                        typeof child == 'number' || typeof child == 'string'
                            ? document.createTextNode(child)
                            : child
                    );
                }
            })(element, child);
        }

        return element;
    }
</script>

<!-- MAIN IMAGE GENERATING FUNCTION -->
<script>
    function generateSVG(config = imageConfig) {
        // Для масштабирования графиков к изображению
        const scales = generateImageScalingConfig();

        // Границы всего картинки
        const imageBorderElement = generateImageBorderElement(config.image.size.full);

        // Линии шкал
        const scaleLines = generateScaleLines(config.image.size.client);
        // Метки шкал
        const scaleScales = generateScaleScales();

        // Линии графиков
        const graphs = generateGraphs();

        // Создание изображения
        return renderSVG(
            SVGTags.SVG,
            { height: config.image.size.full.height, width: config.image.size.full.width, },
            imageBorderElement,
            scaleLines,
            scaleScales,
            graphs,
        );

        // Генерация размеров изобржения для масштабирования
        function generateImageScalingConfig() {
            const scales = {
                func: {
                    horizontal: { min: 0, max: 0, size: 0 },
                    vertical: { min: 0, max: 0, size: 0 },
                },
                image: {
                    horizontal: { min: 0, max: config.image.size.client.width, size: config.image.size.client.width },
                    vertical: { min: 0, max: config.image.size.client.height, size: config.image.size.client.height },
                }
            };

            if (config.image.scales.dynamicScales) {
                setBaseScalesByGraphValues(scales.func.vertical, scales.func.horizontal);
                updScalesByGraphValues(scales.func.vertical, scales.func.horizontal);
            } else if (config.image.scales.hideValuesOutOfScales) {
                setBaseScalesByScalesValues(scales.func.vertical, scales.func.horizontal);
                updScalesByScalesValues(scales.func.vertical, scales.func.horizontal);
            } else {
                setBaseScalesByGraphValues(scales.func.vertical, scales.func.horizontal);
                updScalesByGraphValues(scales.func.vertical, scales.func.horizontal);
                updScalesByScalesValues(scales.func.vertical, scales.func.horizontal);
            }

            return scales;

            // Установка начальных значений
            // По значениям графиков
            function setBaseScalesByGraphValues(v, h) {
                h.min = h.max = config.lines?.[0]?.values?.[0]?.x ?? 0;
                h.size = h.max - h.min;

                v.min = v.max = config.lines?.[0]?.values?.[0]?.y ?? 0;
                v.size = v.max - v.min;
            }

            // По значениям шкал
            function setBaseScalesByScalesValues(v, h) {
                h.min = h.max = config.image.scales?.xScaleValues?.[0] ?? 0;
                h.size = h.max - h.min;

                v.min = v.max = config.image.scales?.yScaleValues?.[0] ?? 0;
                v.size = v.max - v.min;
            }

            // Поиск минимальных и максимальных значений
            // По значениям графиков
            function updScalesByGraphValues(v, h) {
                for (const line of config.lines) {
                    for (const value of line.values) {
                        if (value.x < h.min) {
                            h.min = value.x;
                            h.size = h.max - h.min;
                        } else if (value.x > h.max) {
                            h.max = value.x;
                            h.size = h.max - h.min;
                        }

                        if (value.y < v.min) {
                            v.min = value.y;
                            v.size = v.max - v.min;
                        } else if (value.y > v.max) {
                            v.max = value.y;
                            v.size = v.max - v.min;
                        }
                    }
                }
            }

            // По значениям шкал
            function updScalesByScalesValues(v, h) {
                for (const value of config.image.scales.xScaleValues) {
                    if (value < h.min) {
                        h.min = value;
                        h.size = h.max - h.min;
                    } else if (value > h.max) {
                        h.max = value;
                        h.size = h.max - h.min;
                    }
                }

                for (const value of config.image.scales.yScaleValues) {
                    if (value < v.min) {
                        v.min = value;
                        v.size = v.max - v.min;
                    } else if (value > v.max) {
                        v.max = value;
                        v.size = v.max - v.min;
                    }
                }
            }
        }

        // Генерация границ картинки
        function generateImageBorderElement(size) {
            return renderSVG(SVGTags.Polyline,
                {
                    fill: 'none',
                    stroke: imageConfig.image.colors.imageBorder,
                    ['stroke-width']: '2px',
                    points: pointsToText([
                        { x: 0, y: 0 },
                        { x: size.width, y: 0 },
                        { x: size.width, y: size.height },
                        { x: 0, y: size.height },
                        { x: 0, y: 0 },
                    ]),
                    comment: 'Image border',
                });
        }

        // Маппинг списока точек в атрибут Polyline
        function pointsToText(points) {
            return points.map(v => `${v.x}, ${v.y}`).join(' ');
        }

        // Конвертирование координат
        function convertCoords(x, y) {
            const offset = 5;
            return {
                x: x + (config.image.size.full.width - config.image.size.client.width) - offset,
                y: config.image.size.client.height - y + offset
            };
        }

        // Генерация линии
        function createLine(x1, y1, x2, y2) {
            const s = convertCoords(x1, y1);
            const e = convertCoords(x2, y2);
            return renderSVG(SVGTags.Line, { x1: s.x, y1: s.y, x2: e.x, y2: e.y });
        }

        // Генерация линий шкал
        function generateScaleLines(size) {
            const arrowOffset = 5;
            return renderSVG(
                SVGTags.Group,
                {
                    stroke: config.image.colors.scales,
                    ['stroke-width']: '1px',
                    comment: 'Scale lines and arrows'
                },
                // Горизонтальная линия
                createLine(0, 0, size.width, 0),
                // Горизонтальная стрелка
                createLine(size.width, 0, size.width - arrowOffset, arrowOffset),
                createLine(size.width, 0, size.width - arrowOffset, -arrowOffset),
                // Вертикальная линия
                createLine(0, 0, 0, size.height),
                // Вертикальная стрелка
                createLine(0, size.height, arrowOffset, size.height - arrowOffset),
                createLine(0, size.height, -arrowOffset, size.height - arrowOffset),
            )
        }

        // Скалирование координат
        function scaleCoords(x, y, sourceSize, resultSize) {
            return {
                x: (((x - sourceSize.horizontal.min) / sourceSize.horizontal.size) * resultSize.horizontal.size) + resultSize.horizontal.min,
                y: (((y - sourceSize.vertical.min) / sourceSize.vertical.size) * resultSize.vertical.size) + resultSize.vertical.min,
            };
        }

        // Генерация штрихов шкал
        function generateScaleScales() {
            const gridElements = [];
            const pointsElements = [];
            const textElements = [];

            const pointSize = 5;

            if (config.image.scales.dynamicScales) {
                const xPointPart = config.image.size.client.width / config.image.scales.xPoints;
                const yPointPart = config.image.size.client.height / config.image.scales.yPoints;

                // Горизонтальные
                for (let i = 0; i < config.image.scales.xPoints; i++) {
                    const tempX = xPointPart * i;

                    // Сетка
                    gridElements.push(createLine(tempX, 0, tempX, config.image.size.client.height));
                    // Черта
                    pointsElements.push(createLine(tempX, -pointSize, tempX, pointSize));

                    const funcValue = scaleCoords(tempX, 0, scales.image, scales.func).x.toFixed(2);
                    const valWidth = funcValue.toString().length * config.image.textSize.width;
                    const funcPos = convertCoords(tempX - valWidth / 2, -config.image.textSize.height * 1.5);

                    // Текстовые метки
                    textElements.push(renderSVG(SVGTags.Text, { x: funcPos.x, y: funcPos.y }, funcValue));
                }

                // Вертикальные
                for (let i = 0; i < config.image.scales.yPoints; i++) {
                    const tempY = yPointPart * i;

                    // Сетка
                    gridElements.push(createLine(0, tempY, config.image.size.client.width, tempY));
                    // Черта
                    pointsElements.push(createLine(-pointSize, tempY, pointSize, tempY));

                    const funcValue = scaleCoords(0, tempY, scales.image, scales.func).y.toFixed(2);
                    const valWidth = funcValue.toString().length * config.image.textSize.width;
                    const funcPos = convertCoords(- (valWidth + pointSize * 2), tempY - (config.image.textSize.height / 4));

                    // Текстовые метки
                    textElements.push(renderSVG(SVGTags.Text, { x: funcPos.x, y: funcPos.y }, funcValue));
                }
            } else {
                // Горизонтальные
                for (const xBasePoint of config.image.scales.xScaleValues) {
                    const tempX = scaleCoords(xBasePoint, 0, scales.func, scales.image).x;

                    // Сетка
                    gridElements.push(createLine(tempX, 0, tempX, config.image.size.client.height));
                    // Черта
                    pointsElements.push(createLine(tempX, -pointSize, tempX, pointSize));

                    const funcValue = xBasePoint.toFixed(2);
                    const valWidth = funcValue.toString().length * config.image.textSize.width;
                    const funcPos = convertCoords(tempX - valWidth / 2, -config.image.textSize.height * 1.5);

                    // Текстовые метки
                    textElements.push(renderSVG(SVGTags.Text, { x: funcPos.x, y: funcPos.y }, funcValue));
                }

                // Вертикальные
                for (const yBasePoint of config.image.scales.yScaleValues) {
                    const tempY = scaleCoords(0, yBasePoint, scales.func, scales.image).y;

                    // Сетка
                    gridElements.push(createLine(0, tempY, config.image.size.client.width, tempY));
                    // Черта
                    pointsElements.push(createLine(-pointSize, tempY, pointSize, tempY));

                    const funcValue = yBasePoint.toFixed(2);
                    const valWidth = funcValue.toString().length * config.image.textSize.width;
                    const funcPos = convertCoords(- (valWidth + pointSize * 2), tempY - (config.image.textSize.height / 4));

                    // Текстовые метки
                    textElements.push(renderSVG(SVGTags.Text, { x: funcPos.x, y: funcPos.y }, funcValue));
                }
            }

            addMainLineLabels();

            const gridGroupElement = renderSVG(
                SVGTags.Group,
                { stroke: config.image.colors.scaleGrid, ['stroke-dasharray']: '1, 5', ['stroke-width']: '1px', comment: 'Grid', },
                ...gridElements,
            );
            const pointsGroupElement = renderSVG(
                SVGTags.Group,
                { stroke: config.image.colors.scales, ['stroke-width']: '1px', comment: 'Points', },
                ...pointsElements,
            );
            const textGroupElement = renderSVG(
                SVGTags.Group,
                { fill: config.image.colors.text, ['font-family']: '"Courier New", Courier, monospace', comment: 'Text', },
                ...textElements,
            );

            return renderSVG(
                SVGTags.Group,
                { comment: 'Scales' },
                gridGroupElement,
                pointsGroupElement,
                textGroupElement,
            );

            function addMainLineLabels() {
                // Метка шкалы Х
                const hLablePosX = config.image.size.client.width - config.image.textSize.width;
                const hLablePosY = -config.image.textSize.height * 1.5;
                const hLablePos = convertCoords(hLablePosX, hLablePosY);
                textElements.push(renderSVG(
                    SVGTags.Text,
                    { x: hLablePos.x, y: hLablePos.y, comment: 'Main X label' },
                    config.image.scales.xText,
                ));

                // Метка шкалы Y
                const vLablePosX = -(config.image.textSize.width + pointSize * 2);
                const vLablePosY = config.image.size.client.height - config.image.textSize.height;
                const vLablePos = convertCoords(vLablePosX, vLablePosY);
                textElements.push(renderSVG(
                    SVGTags.Text,
                    { x: vLablePos.x, y: vLablePos.y, comment: 'Main Y label' },
                    config.image.scales.yText,
                ));
            }
        }

        // Генерирование линий графиков
        function generateGraphs() {
            const lines = [];

            if (config.image.scales.hideValuesOutOfScales) {
                for (const line of config.lines) {
                    // const linePoints = line.values
                    //     .map(value => scaleCoords(value.x, value.y, scales.func, scales.image))
                    //     .map(value => convertCoords(value.x, value.y));

                    const segments = [];
                    for (let i = 1; i < line.values.length; i++) {
                        const segment = { a: line.values[i - 1], b: line.values[i] };
                        const visible = clipSegment(
                            segment,
                            scales.func.horizontal.min,
                            scales.func.horizontal.max,
                            scales.func.vertical.min,
                            scales.func.vertical.max
                        );
                        if (visible) {
                            const scaledA = scaleCoords(segment.a.x, segment.a.y, scales.func, scales.image);
                            const scaledB = scaleCoords(segment.b.x, segment.b.y, scales.func, scales.image);

                            segments.push(createLine(scaledA.x, scaledA.y, scaledB.x, scaledB.y));
                        }
                    }

                    lines.push(renderSVG(SVGTags.Group, { stroke: line.color, ['stroke-width']: '1px', }, ...segments));
                }

                // Функция обрезки
                function clipSegment(s, minX, maxX, minY, maxY) {
                    const codes = {
                        a: getCodeKS(s.a),
                        b: getCodeKS(s.b)
                    };

                    while (codes.a | codes.b) {
                        // Отрезок полностью невидим
                        if (codes.a & codes.b) {
                            return false;
                        }

                        // Поменять местами точки отрезка
                        if (codes.a == 0) {
                            [s.a, s.b] = [s.b, s.a];
                            [codes.a, codes.b] = [codes.b, codes.a];
                        }

                        // Смещение отрезка
                        // Точка А левее областивидимости
                        if (codes.a & 1) {
                            s.a.y = s.a.y + (s.b.y - s.a.y) * (minX - s.a.x) / (s.b.x - s.a.x);
                            s.a.x = minX;
                        }
                        // точка A правее области видимости
                        else if (codes.a & 2) {
                            s.a.y = s.a.y + (s.b.y - s.a.y) * (maxX - s.a.x) / (s.b.x - s.a.x);
                            s.a.x = maxX;
                        }
                        // точка A ниже области видимости
                        else if (codes.a & 4) {
                            s.a.x = s.a.x + (s.b.x - s.a.x) * (minY - s.a.y) / (s.b.y - s.a.y);
                            s.a.y = minY;
                        }
                        // точка A выше области видимости
                        else {
                            s.a.x = s.a.x + (s.b.x - s.a.x) * (maxY - s.a.y) / (s.b.y - s.a.y);
                            s.a.y = maxY;
                        }

                        codes.a = getCodeKS(s.a);
                    }

                    return true;

                    // Вычисление кода точки
                    function getCodeKS(point) {
                        let code = 0;

                        if (point.x < minX) {
                            code += 1;
                        } else if (point.x > maxX) {
                            code += 2;
                        }

                        if (point.y < minY) {
                            code += 4;
                        } else if (point.y > maxY) {
                            code += 8;
                        }

                        return code;
                    }
                }
            } else {
                for (const line of config.lines) {
                    const linePoints = line.values
                        .map(value => scaleCoords(value.x, value.y, scales.func, scales.image))
                        .map(value => convertCoords(value.x, value.y));
                    const points = pointsToText(linePoints);

                    lines.push(renderSVG(SVGTags.Polyline, { fill: 'none', ['stroke-width']: '1px', stroke: line.color, points },));
                }
            }

            return renderSVG(
                SVGTags.Group,
                { comment: 'Graphs' },
                ...lines,
            );
        }
    }
</script>

<!-- DRAW GRAPH -->
<script>
    const imageContainer = document.getElementById('content-container');

    imageContainer.innerHTML = '';
    const img = generateSVG(imageConfig);
    imageContainer.appendChild(img);
</script>

</html>